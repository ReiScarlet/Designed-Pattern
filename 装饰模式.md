# 1.装饰模式

## 1.1动机

为某些情况下我们可能会”过度地使用继承来扩展对象的功能“，由于继承为类型引入的静态性质，使得这种拓展方式缺乏灵活性；并且随着子类的增多(拓展功能的增多)，各种子类的组合(拓展功能的组合)会导致更多子类的膨胀

## 1.2 模式定义

动态（组合）地给一个对象增加一些额外地职责。就增加功能而言，Decorator模式比生成子类（继承）更为灵活（消除重复代码&减少子类个数）

## 1.3 要点总结

1. 通过采用组合而非继承地方式，Decorator模式实现了在<u>运行时</u>动态拓展对象功能的能力，而且可以根据需要拓展多个功能。避免了使用继承带来的”灵活性差“和”多子类衍生问题“
2. **Decorator类在接口上表现为is-a Component的继承关系，但在实现上又变现为has-a Component的组合关系**（同时有is-a和has-a的时候，要考虑是不是用了decorator模式）
3. Decorator模式的目的并非为了解决”多子类衍生的多继承问题“，Decorator模式应用的要点在于解决”主体类在多个方向上的拓展功能“——是为”装饰“的含义

